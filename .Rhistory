}
#levels(mydata$Pilk.NonSide) <- c("right", "left")
mydata$Pilk.NonSide <- as.factor(mydata$Pilk.NonSide)
##Find causal/non side for Gorp pretest trial
mydata$Gorp.CausalSide <- NA
for (i in 1:nrow(mydata)) {
if (mydata$Trial.B.1[i] == "Gorp.C") {
mydata$Gorp.CausalSide[i] <- as.character(mydata$Side.B.1[i])
} else if (mydata$Trial.B.1[i] == "Gorp.NC"){
mydata$Gorp.CausalSide[i] <- as.character(mydata$Side.B.2[i]) }
}
mydata$Gorp.CausalSide <- as.factor(mydata$Gorp.CausalSide)
#levels(mydata$Gorp.CausalSide) <- c("left", "right")
mydata$Gorp.NonSide <- NULL
for (i in 1:nrow(mydata)) {
if (mydata$Gorp.CausalSide[i] == "left") {
mydata$Gorp.NonSide[i] <- "right"
} else {
mydata$Gorp.NonSide[i] <- "left" }
}
mydata$Gorp.NonSide <- as.factor(mydata$Gorp.NonSide)
#levels(mydata$Gorp.NonSide) <- c("left", "right")
###
#HAND OUT PRETEST SCORES
###
##Try to give a score for Pilk.Touch.Score
mydata$Pilk.Touch.Score <- NA
for (i in 1:nrow(mydata)) {
if (is.na(mydata$ForceTouch.A.Ans[i])){
##Didn't do forced choice, check free response
mydata$Pilk.Touch.Score[i] <- NA
s = 0
if (mydata$Trial.A.1[i] == "Pilk.C"){
s = s + mydata$Touch.A.1[i] + (1-mydata$Touch.A.2[i])
} else if (mydata$Trial.A.1[i] == "Pilk.NC"){
s = s + mydata$Touch.A.2[i] + (1-mydata$Touch.A.1[i])
}
##Did they get both right?
if (s == 2){
mydata$Pilk.Touch.Score[i] <- 1
} else {
mydata$Pilk.Touch.Score[i] <- 0
}
} else if (mydata$ForceTouch.A.Q[i] == "Touching"){
##Did Forced choice
if (mydata$ForceTouch.A.Ans[i] == mydata$Pilk.CausalSide[i]){
mydata$Pilk.Touch.Score[i] <- 1
} else if (mydata$ForceTouch.A.Ans[i] == mydata$Pilk.NonSide[i]){
mydata$Pilk.Touch.Score[i] <- 0
}
} else if (mydata$ForceTouch.A.Q[i] == "NotTouching"){
if (mydata$ForceTouch.A.Ans[i] == mydata$Pilk.NonSide[i]){
mydata$Pilk.Touch.Score[i] <- 1
} else if (mydata$ForceTouch.A.Ans[i] == mydata$Pilk.CausalSide[i]){
mydata$Pilk.Touch.Score[i] <- 0
}
}
}
##Try to give a score for Pilk.Causal.Score
mydata$Pilk.Cause.Score <- NA
for (i in 1:nrow(mydata)) {
if (is.na(mydata$ForceCause.A.Ans[i])){
mydata$Pilk.Cause.Score[i] <- NA
##Didn't do force choice, check free response
s = 0
if (mydata$Trial.A.1[i] == "Pilk.C"){
s = s + mydata$Cause.A.1[i] + (1-mydata$Cause.A.2[i])
} else if (mydata$Trial.A.1[i] == "Pilk.NC"){
s = s + mydata$Cause.A.2[i] + (1-mydata$Cause.A.1[i])
}
##Did they get both right?
if (s == 2){
mydata$Pilk.Cause.Score[i] <- 1
} else {
mydata$Pilk.Cause.Score[i] <- 0
}
} else if (mydata$ForceCause.A.Q[i] == "SarahDid"){
if (mydata$ForceCause.A.Ans[i] == mydata$Pilk.CausalSide[i]){
mydata$Pilk.Cause.Score[i] <- 1
} else if (mydata$ForceCause.A.Ans[i] == mydata$Pilk.NonSide[i]){
mydata$Pilk.Cause.Score[i] <- 0
}
} else if (mydata$ForceCause.A.Q[i] == "SarahDidnt"){
if (mydata$ForceCause.A.Ans[i] == mydata$Pilk.NonSide[i]){
mydata$Pilk.Cause.Score[i] <- 1
} else if (mydata$ForceCause.A.Ans[i] == mydata$Pilk.CausalSide[i]){
mydata$Pilk.Cause.Score[i] <- 0
}
}
}
##Try to give a score for Gorp.Touch.Score
mydata$Gorp.Touch.Score <- NA
for (i in 1:nrow(mydata)) {
if (is.na(mydata$ForceTouch.B.Ans[i])){
##Didn't do forced choice, check free response
mydata$Gorp.Touch.Score[i] <- NA
s = 0
if (mydata$Trial.B.1[i] == "Gorp.C"){
s = mydata$Touch.B.1[i] + (1-mydata$Touch.B.2[i])
} else if (mydata$Trial.B.1[i] == "Gorp.NC"){
s = mydata$Touch.B.2[i] + (1-mydata$Touch.B.1[i])
}
##Did they get both right?
if (s == 2){
mydata$Gorp.Touch.Score[i] <- 1
} else {
mydata$Gorp.Touch.Score[i] <- 0
}
} else if (mydata$ForceTouch.B.Q[i] == "Touching"){
if (mydata$ForceTouch.B.Ans[i] == mydata$Gorp.CausalSide[i]){
mydata$Gorp.Touch.Score[i] <- 1
} else if (mydata$ForceTouch.B.Ans[i] == mydata$Gorp.NonSide[i]){
mydata$Gorp.Touch.Score[i] <- 0
}
} else if (mydata$ForceTouch.B.Q[i] == "NotTouching"){
if (mydata$ForceTouch.B.Ans[i] == mydata$Gorp.NonSide[i]){
mydata$Gorp.Touch.Score[i] <- 1
} else if (mydata$ForceTouch.B.Ans[i] == mydata$Gorp.CausalSide[i]){
mydata$Gorp.Touch.Score[i] <- 0
}
}
}
##Try to give a score for Gorp.Causal.Score
mydata$Gorp.Cause.Score <- NA
for (i in 1:nrow(mydata)) {
if (is.na(mydata$ForceCause.B.Ans[i])){
mydata$Gorp.Cause.Score[i] <- NA
##Didn't do force choice, check free response
s = 0
if (mydata$Trial.B.1[i] == "Gorp.C"){
s = s + mydata$Cause.B.1[i] + (1-mydata$Cause.B.2[i])
} else if (mydata$Trial.B.1[i] == "Gorp.NC"){
s = s + mydata$Cause.B.2[i] + (1-mydata$Cause.B.1[i])
}
##Did they get both right?
if (s == 2){
mydata$Gorp.Cause.Score[i] <- 1
} else {
mydata$Gorp.Cause.Score[i] <- 0
}
} else if (mydata$ForceCause.B.Q[i] == "SarahDid"){
if (mydata$ForceCause.B.Ans[i] == mydata$Gorp.CausalSide[i]){
mydata$Gorp.Cause.Score[i] <- 1
} else if (mydata$ForceCause.B.Ans[i] == mydata$Gorp.NonSide[i]){
mydata$Gorp.Cause.Score[i] <- 0
}
} else if (mydata$ForceCause.B.Q[i] == "SarahDidnt"){
if (mydata$ForceCause.B.Ans[i] == mydata$Gorp.NonSide[i]){
mydata$Gorp.Cause.Score[i] <- 1
} else if (mydata$ForceCause.B.Ans[i] == mydata$Gorp.CausalSide[i]){
mydata$Gorp.Cause.Score[i] <- 0
}
}
}
##Calculate whether they pass pretest
for (i in 1:nrow(mydata)) {
mydata$Pass.Score[i] <- sum(mydata$Pilk.Touch.Score[i], mydata$Pilk.Cause.Score[i], mydata$Gorp.Touch.Score[i], mydata$Gorp.Cause.Score[i], na.rm=TRUE)
}
##Pass 1 and 6 manually because they got 3/4 of Gorp free questions correct,
##This was only for early pilot kids who didn't get forced choice Qs
mydata[mydata$Subject==1,]$Pass.Score <- 3
mydata[mydata$Subject==6,]$Pass.Score <- 3
##Keep passers only
mydata <- mydata[(mydata$Pass.Score > 2),]
################################################
#####DEMOGRAPHICS
#means days old - Note, make sure it counts subjects, not trials!
collapsed <- mydata[!duplicated(mydata$Subject),]
mean(aggregate(collapsed$Days.Old, by=list(collapsed$Subject), mean))
foo <- subset(collapsed, select=c("Subject", "Days.Old"))
min(foo$Days.Old)
max(foo$Days.Old)
#Number of girls - Note, make sure it counts subjects, not trials!
foo <- subset(collapsed, select=c("Subject", "Gender"))
nrow(foo[foo$Gender=="F",])
nrow(foo[foo$Gender=="M",])
################################################
#######ANALYSIS!
#aggregate the "pilking"/"notpilking" choices in a new dataframe
sum.na.rm <- function(x) { sum(x,na.rm=T) }
NotPilkingScores <- aggregate(mydata$Choice.NC, by=list(mydata$Subject), sum.na.rm)
PilkingScores <- aggregate(mydata$Choice.C, by=list(mydata$Subject), sum.na.rm)
#NotPilkingScores, divided by when you got asked that question! For Review 4/30/15
NotPilkingFirst <- aggregate(mydata[mydata$Yesfirst==0,]$Choice.NC, by=list(mydata[mydata$Yesfirst==0,]$Subject), sum.na.rm)
NotPilkingSecond  <- aggregate(mydata[mydata$Yesfirst==1,]$Choice.NC, by=list(mydata[mydata$Yesfirst==1,]$Subject), sum.na.rm)
mean(NotPilkingFirst$x)
mean(NotPilkingSecond$x)
wilcox.test(NotPilkingFirst$x, NotPilkingSecond$x, exact=FALSE, conf.int=TRUE)
#Means & SEM for graphs!
mean(NotPilkingScores$x)
sd(NotPilkingScores$x)/sqrt(length(NotPilkingScores$x))
mean(PilkingScores$x)
sd(PilkingScores$x)/sqrt(length(PilkingScores$x))
wilcox.test(PilkingScores$x, mu=2, exact=FALSE, conf.int=TRUE)
mean(PilkingScores$x)
wilcox.test(NotPilkingScores$x, mu=2, exact=FALSE, conf.int=TRUE)
mean(NotPilkingScores$x)
#Hm, those confidence intervals don't make a ton of sense!  See bootstrapped version below!
#Did they do okay on the manipulation?  Check touch responses
mydata$IsCausalTouch <- 0
mydata[!is.na(mydata$Touching) & (mydata$Causal.Side=="left") & (mydata$Touching=="left"),]$IsCausalTouch <- 1
mydata[!is.na(mydata$Touching) & (mydata$Causal.Side=="right") & (mydata$Touching=="right"),]$IsCausalTouch <- 1
TouchingScores <- aggregate(mydata$IsCausalTouch, by=list(mydata$Subject), sum)
wilcox.test(TouchingScores$x, mu=2, exact=FALSE, conf.int=TRUE)
mean(TouchingScores$x)
sd(TouchingScores$x)/sqrt(length(TouchingScores$x))
#And condition comparisons
wilcox.test(PilkingScores$x, NotPilkingScores$x, exact=FALSE, paired=TRUE)
wilcox.test(PilkingScores$x, TouchingScores$x, exact=FALSE, paired=TRUE)
#Time for bootstrapped confidence intervals around the means of the 3 conditions!
library(bootstrap)
graphdata <- data.frame(NULL)
touching.boot.mean = bootstrap(TouchingScores$x, 1000, mean)
graphdata <- rbind(graphdata, quantile(touching.boot.mean$thetastar, c(0.025, 0.975)))
pilk.boot.mean = bootstrap(PilkingScores$x, 1000, mean)
graphdata<- rbind(graphdata, quantile(pilk.boot.mean$thetastar, c(0.025, 0.975)))
nopilk.boot.mean = bootstrap(NotPilkingScores$x, 1000, mean)
graphdata<- rbind(graphdata, quantile(nopilk.boot.mean$thetastar, c(0.025, 0.975)))
names(graphdata) <- c("LowCI","HighCI")
graphdata$CondName <- c("Manipulation Check", "Positive Transitive", "Negative Transitive")
#New 3/16/16 make some pretty ggplot graphs
graphdata$Mean[1] <- mean(TouchingScores$x)
graphdata$Mean[2] <- mean(PilkingScores$x)
graphdata$Mean[3] <- mean(NotPilkingScores$x)
graphdata$ToOrder <- c(1,2,3)
barcolors = c("steelblue4", "steelblue4", "steelblue4") #Dumb bug! I am overriding R's default order and the colors don't go with :(
p<- ggplot(graphdata, aes(x=CondName, y=Mean, fill=CondName, group=CondName)) +
geom_bar(stat="identity",) +
aes(x=reorder(CondName, ToOrder)) +
scale_fill_manual(values=barcolors) +
geom_errorbar(aes(ymin=LowCI, ymax=HighCI), colour="black", width=.1) +
coord_cartesian(ylim=c(0,4))+
#theme_set(theme_gray(base_size = 14))+
#ggtitle(title)+
ylab("Mean Causal Choices")+
xlab("")+
theme(legend.position="none")+
geom_hline(aes(yintercept=2), color="black", linetype="dashed")
p
ggsave(filename="E1.jpg", plot=p, width=6, height=4)
setwd("~/Dropbox/_Projects/Wugging/Analysis - Experiment 2")
#This reads in the *.dat data from a forced-choice
#experiment (TVW at the moment!)
#Note: Data cleaning & participant selection (see Participants_TSW for details for fussouts/other exclusions)
#Descriptives & analsyis start line 50
library(reshape)
library(stringr)
library(ggplot2)
library(testit)
library(ggthemes)
library(bootstrap)
assert("Make sure R is pointed at the right working directory", sum(str_detect(dir(), "Data_E2"))==1)
#See setwd() or Session > Set Working Directory > To Source File Location
#DATA LOADING & SHAPING
####Load Datafiles
#Load in the data from the TVW files
mydata <- data.frame(NULL)
max_participant = 131
for(f in 1:max_participant) {
filename = paste('Data_E2/TSW_', f, '.dat', sep='')
tryCatch({
tmp <- read.table(filename, header=FALSE, sep=" ")
names(tmp) <- c("Subject", "Condition", "Trial.Number", "MUSH", "First.Item", "Second.Item",
"First.Side", "Causal.Side", "Response.Causal", "Choice.Causal")
mydata <- rbind(mydata, tmp)
},
error = function(ex) {},
finally = {})
}
#Load in the data about participants and pretest/touch performance
pdata <- data.frame(NULL)
pdata <- read.table('Participants_TSW.csv', header=TRUE, sep=',')
mydata <- merge(mydata, pdata, by=c("Subject"))
#Make sure conditions are labeled correctly
mydata <- mydata[mydata$Experiment != "switch-pilot",]
#THROW OUT people who didn't get included!
#Optional - keep those who just failed pretest!!
mydata[mydata$Exclude.Reason == "FAILED PRETEST",]$Include <- 0
mydata <- mydata[mydata$Include == 1,]
mydata <- mydata[!is.na(mydata$Condition),]
################################################
#####DEMOGRAPHICS
#means days old - Note, it counts subjects not trials
collapsed <- mydata[!duplicated(mydata$Subject),]
transitive <- collapsed[collapsed$Condition=="Transitive",]
intransitive <- collapsed[collapsed$Condition=="Intransitive",]
happen <- collapsed[collapsed$Condition=="Happen",]
length(collapsed$Days.Old)
mean(aggregate(collapsed$Days.Old, by=list(collapsed$Subject), mean))
length(transitive$Days.Old)
mean(aggregate(transitive$Days.Old, by=list(transitive$Subject), mean))
length(intransitive$Days.Old)
mean(aggregate(intransitive$Days.Old, by=list(intransitive$Subject), mean))
length(happen$Days.Old)
mean(aggregate(happen$Days.Old, by=list(happen$Subject), mean))
foo <- subset(collapsed, select=c("Subject", "Days.Old"))
min(foo$Days.Old)
max(foo$Days.Old)
#Number of girls - Note, make sure it counts subjects, not trials!
foo <- subset(collapsed, select=c("Subject", "Gender"))
nrow(foo[foo$Gender=="F",])
nrow(foo[foo$Gender=="M",])
################################################
#######ANALYSIS!
#aggregate the choices in a new dataframe: how many causal choices did you make, 0, 1, or 2
sum.na.rm <- function(x) { sum(x,na.rm=T) }
my.sd <- function(x) {sd(x)/sqrt(length(x))}
Scores <- aggregate(mydata$Choice.Causal, by=list(mydata$Subject), sum.na.rm)
names(Scores) <- c("Subject", "CausalScore")
collapsed <- merge(collapsed,Scores, by=c("Subject"))
with(collapsed, tapply(CausalScore, list(Condition), mean, na.rm=TRUE), drop=TRUE)
with(collapsed, tapply(CausalScore, list(Condition), my.sd), drop=TRUE)
#Check whether each group is different from chance, with wilcox test
wilcox.test(collapsed[collapsed$Condition=="Transitive",]$CausalScore, mu=1, exact=FALSE)
wilcox.test(collapsed[collapsed$Condition=="Intransitive",]$CausalScore, mu=1, exact=FALSE)
wilcox.test(collapsed[collapsed$Condition=="Happen",]$CausalScore, mu=1, exact=FALSE)
#And is transitive different from intransitive?
wilcox.test(collapsed[collapsed$Condition=="Transitive",]$CausalScore, collapsed[collapsed$Condition=="Intransitive",]$CausalScore, exact=FALSE, paired = FALSE)
#And is transitive different from happen?
wilcox.test(collapsed[collapsed$Condition=="Transitive",]$CausalScore, collapsed[collapsed$Condition=="Happen",]$CausalScore, exact=FALSE, paired = FALSE)
#And is happen different from intransitive?
wilcox.test(collapsed[collapsed$Condition=="Happen",]$CausalScore, collapsed[collapsed$Condition=="Intransitive",]$CausalScore, exact=FALSE, paired = FALSE)
#Time for bootstrapped confidence intervals around the means of the 3 conditions!
graphdata <- data.frame(NULL)
happen.boot.mean = bootstrap(collapsed[collapsed$Condition=="Happen",]$CausalScore, 1000, mean)
graphdata <- rbind(graphdata,quantile(happen.boot.mean$thetastar, c(0.025, 0.975)))
trans.boot.mean = bootstrap(collapsed[collapsed$Condition=="Transitive",]$CausalScore, 1000, mean)
graphdata <- rbind(graphdata,quantile(trans.boot.mean$thetastar, c(0.025, 0.975)))
intrans.boot.mean = bootstrap(collapsed[collapsed$Condition=="Intransitive",]$CausalScore, 1000, mean)
graphdata <- rbind(graphdata,quantile(intrans.boot.mean$thetastar, c(0.025, 0.975)))
names(graphdata) <- c("LowCI","HighCI")
graphdata$CondName <- c("Manipulation Check", "Transitive", "Intransitive")
#New 3/16/16 make some pretty ggplot graphs
graphdata$Mean[1] <- mean(collapsed[collapsed$Condition=="Happen",]$CausalScore)
graphdata$Mean[2] <- mean(collapsed[collapsed$Condition=="Transitive",]$CausalScore)
graphdata$Mean[3] <- mean(collapsed[collapsed$Condition=="Intransitive",]$CausalScore)
graphdata$ToOrder <- c(1,2,3)
barcolors = c("steelblue2", "steelblue4", "steelblue3") #Dumb bug! I am overriding R's default order and the colors don't go with :(
p<- ggplot(graphdata, aes(x=CondName, y=Mean, fill=CondName, group=CondName)) +
geom_bar(stat="identity",) +
aes(x=reorder(CondName, ToOrder)) +
scale_fill_manual(values=barcolors) +
geom_errorbar(aes(ymin=LowCI, ymax=HighCI), colour="black", width=.1) +
coord_cartesian(ylim=c(0,2))+
#theme_set(theme_gray(base_size = 14))+
#ggtitle(title)+
ylab("Mean Causal Choices")+
xlab("")+
theme(legend.position="none")+
geom_hline(aes(yintercept=1), color="black", linetype="dashed")
p
ggsave(filename="E2.jpg", plot=p, width=6, height=4)
#This reads in the *.dat data from a forced-choice
#experiment (TVW at the moment!)
#Note: Data cleaning & participant selection (see Participants_TSW for details for fussouts/other exclusions)
#Descriptives & analsyis start line 50
library(reshape)
library(stringr)
library(ggplot2)
library(testit)
library(ggthemes)
library(bootstrap)
assert("Make sure R is pointed at the right working directory", sum(str_detect(dir(), "Data_E2"))==1)
#See setwd() or Session > Set Working Directory > To Source File Location
#DATA LOADING & SHAPING
####Load Datafiles
#Load in the data from the TVW files
mydata <- data.frame(NULL)
max_participant = 131
for(f in 1:max_participant) {
filename = paste('Data_E2/TSW_', f, '.dat', sep='')
tryCatch({
tmp <- read.table(filename, header=FALSE, sep=" ")
names(tmp) <- c("Subject", "Condition", "Trial.Number", "MUSH", "First.Item", "Second.Item",
"First.Side", "Causal.Side", "Response.Causal", "Choice.Causal")
mydata <- rbind(mydata, tmp)
},
error = function(ex) {},
finally = {})
}
#Load in the data about participants and pretest/touch performance
pdata <- data.frame(NULL)
pdata <- read.table('Participants_TSW.csv', header=TRUE, sep=',')
mydata <- merge(mydata, pdata, by=c("Subject"))
#Make sure conditions are labeled correctly
mydata <- mydata[mydata$Experiment != "switch-pilot",]
#THROW OUT people who didn't get included!
#Optional - keep those who just failed pretest!!
mydata[mydata$Exclude.Reason == "FAILED PRETEST",]$Include <- 0
mydata <- mydata[mydata$Include == 1,]
mydata <- mydata[!is.na(mydata$Condition),]
################################################
#####DEMOGRAPHICS
#means days old - Note, it counts subjects not trials
collapsed <- mydata[!duplicated(mydata$Subject),]
transitive <- collapsed[collapsed$Condition=="Transitive",]
intransitive <- collapsed[collapsed$Condition=="Intransitive",]
happen <- collapsed[collapsed$Condition=="Happen",]
length(collapsed$Days.Old)
mean(aggregate(collapsed$Days.Old, by=list(collapsed$Subject), mean.na.rm))
help(mean)
#This reads in the *.dat data from a forced-choice
#experiment (TVW at the moment!)
#Note: Data cleaning & participant selection (see Participants_TSW for details for fussouts/other exclusions)
#Descriptives & analsyis start line 50
library(reshape)
library(stringr)
library(ggplot2)
library(testit)
library(ggthemes)
library(bootstrap)
assert("Make sure R is pointed at the right working directory", sum(str_detect(dir(), "Data_E2"))==1)
#See setwd() or Session > Set Working Directory > To Source File Location
#DATA LOADING & SHAPING
####Load Datafiles
#Load in the data from the TVW files
mydata <- data.frame(NULL)
max_participant = 131
for(f in 1:max_participant) {
filename = paste('Data_E2/TSW_', f, '.dat', sep='')
tryCatch({
tmp <- read.table(filename, header=FALSE, sep=" ")
names(tmp) <- c("Subject", "Condition", "Trial.Number", "MUSH", "First.Item", "Second.Item",
"First.Side", "Causal.Side", "Response.Causal", "Choice.Causal")
mydata <- rbind(mydata, tmp)
},
error = function(ex) {},
finally = {})
}
#Load in the data about participants and pretest/touch performance
pdata <- data.frame(NULL)
pdata <- read.table('Participants_TSW.csv', header=TRUE, sep=',')
mydata <- merge(mydata, pdata, by=c("Subject"))
#Make sure conditions are labeled correctly
mydata <- mydata[mydata$Experiment != "switch-pilot",]
#THROW OUT people who didn't get included!
#Optional - keep those who just failed pretest!!
mydata[mydata$Exclude.Reason == "FAILED PRETEST",]$Include <- 0
mydata <- mydata[mydata$Include == 1,]
mydata <- mydata[!is.na(mydata$Condition),]
################################################
#####DEMOGRAPHICS
#means days old - Note, it counts subjects not trials
collapsed <- mydata[!duplicated(mydata$Subject),]
transitive <- collapsed[collapsed$Condition=="Transitive",]
intransitive <- collapsed[collapsed$Condition=="Intransitive",]
happen <- collapsed[collapsed$Condition=="Happen",]
length(collapsed$Days.Old)
mean(aggregate(collapsed$Days.Old, by=list(collapsed$Subject), na.rm = TRUE))
length(transitive$Days.Old)
collapsed$Days.Old
mean(collapsed$Days.Old)
collapsed
length(collapsed$Days.Old)
mean(collapsed$Days.Oldna.rm = TRUE)
length(transitive$Days.Old)
mean(aggregate(transitive$Days.Old, by=list(transitive$Subject), mean))
length(intransitive$Days.Old)
mean(aggregate(intransitive$Days.Old, by=list(intransitive$Subject), mean))
length(happen$Days.Old)
mean(aggregate(happen$Days.Old, by=list(happen$Subject), mean))
length(collapsed$Days.Old)
mean(collapsed$Days.Old, na.rm = TRUE)
length(transitive$Days.Old)
mean(aggregate(transitive$Days.Old, by=list(transitive$Subject), mean))
length(intransitive$Days.Old)
mean(aggregate(intransitive$Days.Old, by=list(intransitive$Subject), mean))
length(happen$Days.Old)
mean(aggregate(happen$Days.Old, by=list(happen$Subject), mean))
length(collapsed$Days.Old)
mean(collapsed$Days.Old, na.rm = TRUE)
length(transitive$Days.Old)
mean(transitive$Days.Old)
length(intransitive$Days.Old)
mean(intransitive$Days.Old)
length(happen$Days.Old)
mean(happen$Days.Old)
#Number of girls - Note, make sure it counts subjects, not trials!
foo <- subset(collapsed, select=c("Subject", "Gender"))
nrow(foo[foo$Gender=="F",])
nrow(foo[foo$Gender=="M",])
collapsed
collapsed$Gender
collapsed$Gender[213]
collapsed$Gender[213,]
collapsed$Gender[,213]
collapsed$Gender[213]
collapsed$Gender[-2]
collapsed$Gender
collapsed
collapsed$Gender
collapsed$Condition
#aggregate the choices in a new dataframe: how many causal choices did you make, 0, 1, or 2
sum.na.rm <- function(x) { sum(x,na.rm=T) }
my.sd <- function(x) {sd(x)/sqrt(length(x))}
Scores <- aggregate(mydata$Choice.Causal, by=list(mydata$Subject), sum.na.rm)
names(Scores) <- c("Subject", "CausalScore")
collapsed <- merge(collapsed,Scores, by=c("Subject"))
with(collapsed, tapply(CausalScore, list(Condition), mean, na.rm=TRUE), drop=TRUE)
with(collapsed, tapply(CausalScore, list(Condition), my.sd), drop=TRUE)
wilcox.test(collapsed[collapsed$Condition=="Happen",]$CausalScore, mu=1, exact=FALSE)
wilcox.test(collapsed[collapsed$Condition=="Intransitive",]$CausalScore, mu=1, exact=FALSE)
wilcox.test(collapsed[collapsed$Condition=="Transitive",]$CausalScore, collapsed[collapsed$Condition=="Intransitive",]$CausalScore, exact=FALSE, paired = FALSE)
wilcox.test(collapsed[collapsed$Condition=="Transitive",]$CausalScore, collapsed[collapsed$Condition=="Happen",]$CausalScore, exact=FALSE, paired = FALSE)
#Compare 3s and 4s
threes <- collapsed[collapsed$Age.Years == 3,]
fours <- collapsed[collapsed$Age.Years == 4,]
with(threes, tapply(CausalScore, list(Condition), mean, na.rm=TRUE), drop=TRUE)
with(fours, tapply(CausalScore, list(Condition), mean, na.rm=TRUE), drop=TRUE)
wilcox.test(threes[threes$Condition=="Transitive",]$CausalScore, fours[fours$Condition=="Transitive",]$CausalScore, exact=FALSE)
wilcox.test(threes[threes$Condition=="Intransitive",]$CausalScore, fours[fours$Condition=="Intransitive",]$CausalScore, exact=FALSE)
wilcox.test(threes[threes$Condition=="Happen",]$CausalScore, fours[fours$Condition=="Happen",]$CausalScore, exact=FALSE)
